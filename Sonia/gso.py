# -*- coding: utf-8 -*-
"""GSO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bABMNVEB5NNMQmpMf21yX3g2oKuDKclf
"""

import pandas as pd
import numpy as np
import random

from sklearn.datasets import load_digits
from sklearn.svm import SVC
from sklearn.model_selection import cross_val_score

data = load_digits()
n_samples = len(data.images)
X = data.images.reshape((n_samples, -1))
Y = data['target']

def fitness_function(x):
  clf = SVC(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
  scores = cross_val_score(clf, X, Y, cv=5)

  return scores.mean()

# define range for input
bounds = [[1.0, 10.0], [0.0001, 0.1]]

# define the total iterations
Generations = 10

# define the population size
n_pop = 10

#define the parameters
params = ["C", "gamma"]

# luciferin_decay_const
rho = 0.3

#luciferin_enhacement_const
gamma = 0.65

#step_size
s = 0.5

#sensor_range
rs = 0.45

#neighborhood_range
r0 = 4

#rate of range of neighborhood
betta = 0.075

#intial luciferin
l0 = 0.25

def GSO(bounds, Generations, n_pop, rho, gamma, s, rs, r0, betta, l0):
  t = 0
  #population generation
  XCmin, XGmin = bounds[0][0], bounds[1][0]
  XCmax, XGmax  = bounds[0][1], bounds[1][1]

  population = pd.DataFrame()

  pop = list()
  for _ in range(n_pop):

    xc = max(XCmin, min(XCmax, XCmin + random.uniform(0,1)*(XCmax - XCmin)))
    xg = max(XGmin, min(XGmax, XGmin + random.uniform(0,1)*(XGmax - XGmin)))
    pop.append((xc, xg))

  population[['C', 'gamma']] = list(pop)

  population['fit'] = [fitness_function(x) for x in population[['C', 'gamma']].values]


  # keep track of best solution
  t = 0
  best_sol_index = population["fit"].idxmax()
  best_para, best_fit = (population["C"].loc[best_sol_index],
                          population["gamma"].loc[best_sol_index]), population["fit"].loc[best_sol_index]

  print(">%d, new best C and gamma:%s, best_fit %f" % (t,  best_para, best_fit))


  #initialization of the luciferin and the neighborhood range
  population['luciferin'] = l0
  population['neigh_rng'] = r0

  population['neigh'] = ""
  population['prob_mov'] = 0

  while t < Generations:
    for i in range(n_pop):
      #update luciferin level:
      population.loc[i, ['luciferin']] = (1-rho)*(population.loc[i, ['luciferin']])
      + gamma*fitness_function(population.loc[i, ['C', 'gamma']])

    for i in range(n_pop):
      #define the neighborhood:

      indexes = list(population.index)
      indexes.remove(i)
      for j in indexes:
        if population.loc[i, ['luciferin']]<population.loc[j, ['luciferin']]:
          #euclidean distance:
          a, b = population.loc[i, ['C', 'gamma']], population.loc[j, ['C', 'gamma']]
          dist = np.linalg.norm(a-b)

          if dist<population.loc[i, ['neigh_rng']]:
            #population.at[j, ['neigh']] = population.loc[j, ['neigh']].append([j])
            pass
        
      s = sum(population.loc[i, ['luciferin']])
      for k in population.loc[i, ['neigh_rng']].values:
        #probability of moving:
        s += sum(population.loc[k, ['luciferin']])
      
      #prob of moving:
      population['prob'] = (population.loc[j, ['luciferin']] - population.loc[i, ['luciferin']])/s

      idx_j = population['prob'].idxmax()
      
      #update glowworm movement:
      population.loc[i, ['C']] = population.loc[i, ['C']] + s*((population.loc[j, ['C']] - population.loc[i, ['C']])/
                                                              np.linalg.norm(population.loc[j, ['C']] - population.loc[i, ['C']], 1))
      
      population.loc[i, ['gamma']] = population.loc[i, ['gamma']] + s*((population.loc[j, ['gamma']] - population.loc[i, ['gamma']])/
                                                              np.linalg.norm(population.loc[j, ['gamma']] - population.loc[i, ['gamma']], 1))
      
      #update the neighborhood range
      population.loc[i, ['neigh_rng']] = min(rs, max(0, population.loc[i, ['neigh_rng']]+betta*(population.loc[i, ['neigh']] - np.abs(population.loc[i, ['neigh']]))))


      #update the fitness function:
      best_sol_index = population["fit"].idxmax()
      best_para, best_fit = (population["C"].loc[best_sol_index],
                              population["gamma"].loc[best_sol_index]), population["fit"].loc[best_sol_index]

      print(">%d, new best C and gamma:%s, best_fit %f" % (t,  best_para, best_fit))

    t += 1
    return best_para, best_fit