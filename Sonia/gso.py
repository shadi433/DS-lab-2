# -*- coding: utf-8 -*-
"""gso.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f55w899uBf6pn375DFDJMzosZCkoZCy4
"""

import pandas as pd
import numpy as np
import random

class GSO:
  def __init__(self, bounds, n_pop, rho, gamma, s, rs, r0, betta, l0, generations, X, Y):
    
    self.t = 0
    self.bounds = bounds
    self.rho = rho
    self.n_pop = n_pop
    self.gamma = gamma
    self.s = s
    self.rs = rs
    self.r0 = r0
    self.betta = betta
    self.l0 = l0
    self.generations = generations

    self.X = X
    self.Y = Y

    #population generation
    self.XCmin, self.XGmin = self.bounds[0][0], self.bounds[1][0]
    self.XCmax, self.XGmax  = self.bounds[0][1], self.bounds[1][1]
    self.population = pd.DataFrame()
    self.pop = list()

      #initialization of the luciferin and the neighborhood range
      population['luciferin'] = self.l0
      population['neigh_rng'] = self.r0

      population['neigh'] = ""
      population['prob_mov'] = 0

    def __cal__(self):
      xc = max(self.XCmin, min(self.XCmaself.x, self.XCmin + random.uniform(0,1)*(self.XCmaself.x - self.XCmin)))
      xg = max(self.XGmin, min(self.XGmax, self.XGmin + random.uniform(0,1)*(self.XGmax - self.XGmin)))
      self.pop.append((xc, xg))

      self.population[['C', 'gamma']] = list(self.pop)
      self.population['fit'] = [self.fitness_function(x) for x in population[['C', 'gamma']].values]
      best_para, best_fit, best_sol_index = self.keep_track_best_sol()

      while(self.t< self.generations):
        for i in range(self.n_pop):
          #update luciferin level:
          self.population.loc[i, ['luciferin']] = (1-self.rho)*(self.population.loc[i, ['luciferin']])
          + self.gamma*self.fitness_function(self.population.loc[i, ['C', 'gamma']])
        for i in range(self.n_pop):
          #define the neighborhood:

          indexes = list(self.population.index)
          indexes.remove(i)
          for j in indexes:
            if self.population.loc[i, ['luciferin']]<self.population.loc[j, ['luciferin']]:
              #euclidean distance:
              a, b = self.population.loc[i, ['C', 'gamma']], self.population.loc[j, ['C', 'gamma']]
              dist = np.linalg.norm(a-b)

              if dist<self.population.loc[i, ['neigh_rng']]:
                #population.at[j, ['neigh']] = population.loc[j, ['neigh']].append([j])
                pass
          self.s = sum(self.population.loc[i, ['luciferin']])
          for k in self.population.loc[i, ['neigh_rng']].values:
            #probability of moving:
            self.s += sum(self.population.loc[k, ['luciferin']])
          #prob of moving:
          self.population['prob'] = (self.population.loc[j, ['luciferin']] - self.population.loc[i, ['luciferin']])/self.s

          idx_j = self.population['prob'].idxmax()
          
          #update glowworm movement:
          self.population.loc[i, ['C']] = self.population.loc[i, ['C']] + s*((self.population.loc[j, ['C']] - self.population.loc[i, ['C']])/
                                                                  np.linalg.norm(self.population.loc[j, ['C']] - self.population.loc[i, ['C']], 1))
          
          self.population.loc[i, ['gamma']] = self.population.loc[i, ['gamma']] + self.s*((self.population.loc[j, ['gamma']] - self.population.loc[i, ['gamma']])/
                                                                  np.linalg.norm(self.population.loc[j, ['gamma']] - self.population.loc[i, ['gamma']], 1))
          
          #update the neighborhood range
          self.population.loc[i, ['neigh_rng']] = min(self.rs, max(0, self.population.loc[i, ['neigh_rng']]+self.betta*(self.population.loc[i, ['neigh']] - np.abs(population.loc[i, ['neigh']]))))
          
          #update the fitness function:
          best_para, best_fit, best_sol_index = self.keep_track_best_sol()
        self.t += 1
      return best_para, best_fit

    def fitness_function(self, x):
      clf = SVC(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
      scores = cross_val_score(clf, self.X, self.Y, cv=5)

      return scores.mean()
    def keep_track_best_sol(self):
      self.t = 0
      best_sol_index = self.population["fit"].idxmax()
      best_para, best_fit = (self.population["C"].loc[best_sol_index],
                              self.population["gamma"].loc[best_sol_index]), self.population["fit"].loc[best_sol_index]

      print(">%d, new best C and gamma:%s, best_fit %f" % (t,  best_para, best_fit))
      return best_para, best_fit, best_sol_index