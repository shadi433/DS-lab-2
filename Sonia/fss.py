# -*- coding: utf-8 -*-
"""fss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CAwMtvIs_shvj1ibGkzNg-P6_5dcA8-w
"""

import pandas as pd
import numpy as np
import random
from swarm import swarm_opt

np.seterr(all="ignore")

class FSS(swarm_opt):
  def __init__(self, Sinit, Sfinal, swarm):
    
    super().__init__(swarm.bounds, swarm.n_pop, swarm.cycles, swarm.fitness_function, swarm.population)

    if isinstance(self.population, dict):
      self.population = pd.DataFrame.from_dict(self.population)
      self.n_pop = len(self.population)

    self.population['w'] = 1

    self.Sinit = Sinit
    self.Sfinal = Sfinal
    self.Sind = self.Sinit

    self.old_population = self.population.copy()

  def __call__(self):
    self.keep_track(self.population['Fit'].idxmax())

    for _ in range(self.cycles):

      self.update_position_sind()
      delta_fit = self.update_weight()
      self.update_position_col_ins_mov(delta_fit)
      B = self.baryCenter()
      self.update_position_col_vol_mov(B)
    
    return self.best_para, self.best_fit
    
  def update_position_sind(self):
    for i in range(self.n_pop):
      
      #update position based on Sind
      self.Sind = self.Sind - (self.Sinit- self.Sfinal)/self.cycles

      for p in self.bounds.keys():
        x = self.population[p][i] + random.uniform(0,1)*self.Sind
        self.population.loc[i, p] = self.clip(p, x)
      
      self.population.loc[i, 'Fit'] = self.fitness_function(self.population[self.bounds.keys()].values[i])
    
    if self.population['Fit'].max()>self.best_fit:
      self.best += 1
      self.keep_track(self.population['Fit'].idxmax())
  
  def update_weight(self):
    #update weight
    delta_fit = [np.abs(self.population['Fit'][i] - self.old_population['Fit'][i]) for i in range(self.n_pop)]
    for i in range(self.n_pop):
      self.population.loc[i, 'w'] = self.population['w'][i] + delta_fit[i]/max(delta_fit)
    return delta_fit

    
  def update_position_col_ins_mov(self, delta_fit):
    #update position based on their collective instinctive mov
    #avrg ind mov
    delta_fit_population = dict()
    I = dict()
    for p in self.bounds.keys():
      delta_fit_population[p] = [(np.abs(self.population[p][i] - self.old_population[p][i])*delta_fit[i]) for i in range(self.n_pop)]
      I[p] = sum(delta_fit_population[p])/sum(delta_fit)
    
    for i in range(self.n_pop):
      for p in self.bounds.keys():
        x = self.population[p][i] + I[p]
        self.population.loc[i, p] = self.clip(p, x)

      self.population.loc[i, 'Fit']= self.fitness_function(self.population[self.bounds.keys()].values[i])

    if self.population['Fit'].max()>self.best_fit:
      self.best += 1
      self.keep_track(self.population['Fit'].idxmax())
      

  def baryCenter(self):
    #BaryCenter
    pop_weight = dict()
    B = dict()
    for p in self.bounds.keys():
      pop_weight[p] = [(self.population[p][i] * self.population['w'][i]) for i in range(self.n_pop)]
      B[p] = sum(pop_weight[p])/sum(self.population['w'])
    return B
  
  def update_position_col_vol_mov(self, B):
    #collective volatile mov
    Svol = 2*self.Sind
    
    #updates fishes position
    for i in range(self.n_pop):
      for p in self.bounds.keys():
        x = self.population[p][i] + Svol*random.uniform(0,1)*((self.population[p][i] - B[p])/(np.sqrt((self.population[p][i] - B[p])**2)))
        self.population.loc[i, p] = self.clip(p, x)

      self.population.loc[i, 'Fit']= self.fitness_function(self.population[self.bounds.keys()].values[i])
    
    if self.population['Fit'].max()>self.best_fit:
      self.best += 1
      self.keep_track(self.population['Fit'].idxmax())

if __name__ == '__main__':
  from sklearn.datasets import load_digits
  from sklearn.svm import SVC
  from sklearn.model_selection import cross_val_score

  data = load_digits()
  n_samples = len(data.images)
  X = data.images.reshape((n_samples, -1))
  Y = data['target']

  def fitness_function(x):
    clf = SVC(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
    scores = cross_val_score(clf, X, Y, cv=5)

    return scores.mean()
  
  bounds = {"C": [0.001, 10.0], "gamma": [0.0001, 0.1]}
  n_pop = 10
  cycles = 10

  Sinit = 0.1

  Sfinal = 0.0001


  swarm = swarm_opt(bounds, n_pop, cycles, fitness_function)

  fss = FSS(Sinit, Sfinal, swarm)
  fss()
