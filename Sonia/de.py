# -*- coding: utf-8 -*-
"""de.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cE5cX9jCiD0LrqqEG_5VjIITVs8yw3bZ
"""

import pandas as pd
import numpy as np
import random

class de:
  def __init__(self, bounds, generations, n_pop, params, CR, model, X, Y):
    self.bounds = bounds
    self.generations = generations
    self.n_pop = n_pop
    
    self.params = self.params
    self.model = model
    self.CR = CR
    
    self.X = X
    self.Y = Y
  
  def __call__(self):
    #population generation
    XCmin, XGmin = bounds[0][0], bounds[1][0]
    XCmax, XGmax  = bounds[0][1], bounds[1][1]

    population = pd.DataFrame()

    pop = list()
    for _ in range(n_pop):

      xc = max(XCmin, min(XCmax, XCmin + random.uniform(0,1)*(XCmax - XCmin)))
      xg = max(XGmin, min(XGmax, XGmin + random.uniform(0,1)*(XGmax - XGmin)))
      pop.append((xc, xg))

    population[['C', 'gamma']] = list(pop)

    population['fit'] = [self.fitness_function(x) for x in population[['C', 'gamma']].values]

    g = 0
    
    best_para, best_fit = self.keep_track_best_sol(g, population)

    while g < self.enerations:
      for i in range(self.n_pop):
        x = population[['C', 'gamma']].loc[i]
        y = self.generate_mutant(i, population)
        z = self.Binomial_crossover(x, y)
        if self.fitness_function(z) > population['fit'].loc[i]:
          population.loc[i, ['C', 'gamma']] = z
          population.loc[i, ['fit']] = self.fitness_function(z)
      g += 1
      #keeping tracking the best solution:
      if population["fit"].max()>best_fit:
        best_para, best_fit = self.keep_track_best_sol(g, population)
    return best_para, best_fit

  def fitness_function(self, x):
    # for i in len(self.params):
    #   params[i] = x[i]
    clf = model(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
    scores = cross_val_score(clf, self.X, self.Y, cv=5)

    return scores.mean()
  def keep_track_best_sol(self, g, population):
    best_sol_index = population["fit"].idxmax()
    best_para, best_fit = (population["C"].loc[best_sol_index],
                            population["gamma"].loc[best_sol_index]), population["fit"].loc[best_sol_index]

    print(">%d, new best C and gamma:%s, best_fit %f" % (g,  best_para, best_fit))
    return best_para, best_fit
  
  def generate_mutant(self, i, population):
    #parent vector
    x = population.loc[i, ['C','gamma']]

    #Selecting from population three random distinct vectors
    indexes = list(population.index)
    indexes.remove(i)
    trg_i, rnd1_i, rnd2_i = random.sample(indexes, 3)

    trg = population.loc[trg_i, ['C','gamma']]
    rnd1 = population.loc[rnd1_i, ['C','gamma']]
    rnd2 = population.loc[rnd2_i, ['C','gamma']]

    #generation of the mutant vector
    c = trg['C'] + random.uniform(0,1)*(rnd1['C'] - rnd2['C'])
    y_c = max(self.bounds[0][0], min(self.bounds[0][1], c))
    
    gamma = trg['gamma'] + random.uniform(0,1)*(rnd1['gamma'] - rnd2['gamma'])
    y_gamma = max(self.bounds[1][0], min(self.bounds[1][1], gamma))

    return [y_c, y_gamma]
  
  def Binomial_crossover(self, x, y):
    #initialization of the output vector as x
    z = x

    #selecting random param
    k = random.randint(0,1)

    for j in range(len(self.params)):
      if random.uniform(0,1) < CR or j!=k:
        z[j] = y[j]
  
    return z