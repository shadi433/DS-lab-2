# -*- coding: utf-8 -*-
"""de.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cE5cX9jCiD0LrqqEG_5VjIITVs8yw3bZ
"""

import pandas as pd
import numpy as np
import random
from swarm import swarm_opt

class DE(swarm_opt):
  def __init__(self, cr, swarm):
    super().__init__(swarm.bounds, swarm.n_pop, swarm.cycles, swarm.fitness_function, swarm.population)
    if isinstance(self.population, dict):
      self.population = pd.DataFrame.from_dict(self.population)
      self.n_pop = len(self.population)
    self.cr = cr

  def __call__(self):
    
    self.keep_track(self.population['Fit'].idxmax())

    for _ in range(self.cycles):
      for i in range(self.n_pop):
        x = self.population.loc[i].to_dict()
        y = self.generate_mutant(i, self.population)
        z = self.Binomial_crossover(x, y)

        fit = self.fitness_function(list(z.values()))
        if fit > self.population['Fit'].loc[i]:
          for param in z.keys():
            self.population.loc[i, param] = z[param]
          self.population.loc[i, 'Fit'] = fit
      
      if self.population['Fit'].max()>self.best_fit:
        self.best += 1
        self.keep_track(self.population['Fit'].idxmax())

    return self.best_para, self.best_fit

  def generate_mutant(self, i, population):
    #parent vector
    x = self.population.loc[i]

    #Selecting from population three random distinct vectors
    indexes = list(self.population.index)
    indexes.remove(i)
    trg_i, rnd1_i, rnd2_i = random.sample(indexes, 3)

    trg = self.population.loc[trg_i]
    rnd1 = self.population.loc[rnd1_i]
    rnd2 = self.population.loc[rnd2_i]

    #generation of the mutant vector
    y = dict()
    for param in self.bounds.keys():
      x = trg[param] + random.uniform(0,1)*(rnd1[param] - rnd2[param])
      y[param] = self.clip(param, x)
    return y


  def Binomial_crossover(self, x, y):
    #initialization of the output vector as x
    z = x.copy()

    #selecting random param (between 0 and len of keys)
    param = random.choice(list(self.bounds.keys()))

    for p in self.bounds.keys():
      if random.uniform(0,1) < self.cr or p!=param:
        z[p] = y[p]
  
    return z

if __name__ == '__main__':
  from sklearn.datasets import load_digits
  from sklearn.svm import SVC
  from sklearn.model_selection import cross_val_score

  data = load_digits()
  n_samples = len(data.images)
  X = data.images.reshape((n_samples, -1))
  Y = data['target']

  def fitness_function(x):
    clf = SVC(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
    scores = cross_val_score(clf, X, Y, cv=5)

    return scores.mean()
  
  bounds = {"C": [0.001, 10.0], "gamma": [0.0001, 0.1]}
  n_pop = 10
  cycles = 10
  #crossover rate
  cr = 0.9

  swarm = swarm_opt(bounds, n_pop, cycles, fitness_function)

  de = DE(cr, swarm)
  de()
