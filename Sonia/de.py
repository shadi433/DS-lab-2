# -*- coding: utf-8 -*-
"""de.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RYrt33Ron_ghvfMIy4PNlw15hmW-9jp0
"""

import pandas as pd
import numpy as np
import random

class DE:
  def __init__(self, bounds, cycles, n_pop, cr, fitness_function, population=None):
    
    self.bounds = bounds
    self.cycles = cycles
    self.n_pop = n_pop

    # crossover rate
    self.cr = cr

    self.fitness_function = fitness_function
    self.population = population

    if self.population == None:
      #populaiton generation
      self.population_dict = self.init_pop()
      self.population = pd.DataFrame.from_dict(self.population_dict)
      #calculating the Fit of the initialised population (employed bees)
      self.population['Fit'] = [fitness_function(x) for x in list(zip(*self.population_dict.values()))]
    else:
      self.population = pd.DataFrame.from_dict(self.population)
      self.population['Fit'] = [fitness_function(x) for x in list(zip(*self.population.values()))]

    # keep track of best solution
    self.best = 0
    self.best_para, self.best_fit = self.keep_track(self.population["Fit"].idxmax())

  def __call__(self):
    for _ in range(self.cycles):
      for i in range(self.n_pop):
        x = self.population.loc[i].to_dict()
        y = self.generate_mutant(i, self.population)
        z = self.Binomial_crossover(x, y)

        fit = self.fitness_function(z)
        if fit > self.population['Fit'].loc[i]:
          for param in z.keys():
            self.population.loc[i, [param]] = z[param]
          self.population.loc[i, ['Fit']] = fit
      
      if self.population['Fit'].max()>self.best_fit:
        self.best += 1
        self.best_para, self.best_fit = self.keep_track(self.population['Fit'].idxmax())

  
  def init_pop(self):
    population_dict = dict()
    for i in range(self.n_pop):
      for key in self.bounds.keys():
        if i == 0:
          population_dict[key] = [bounds[key][0] + random.uniform(0,1)*(bounds[key][-1] - bounds[key][0])]
        else:
          population_dict[key].append(self.bounds[key][0] + random.uniform(0,1)*(self.bounds[key][-1] - self.bounds[key][0]))
    return population_dict
  
  def keep_track(self, best_sol_index):
    best_para = [{key: self.population[key].loc[best_sol_index]} for key in self.bounds.keys()]
    best_fit = self.population["Fit"].loc[best_sol_index]
    print(f"{self.best}, best fit: {best_fit}.")
    print(f'best params: ', best_para)
    return best_para, best_fit

  def generate_mutant(self, i, population):
    #parent vector
    x = self.population.loc[i]

    #Selecting from population three random distinct vectors
    indexes = list(self.population.index)
    indexes.remove(i)
    trg_i, rnd1_i, rnd2_i = random.sample(indexes, 3)

    trg = self.population.loc[trg_i]
    rnd1 = self.population.loc[rnd1_i]
    rnd2 = self.population.loc[rnd2_i]

    #generation of the mutant vector
    y = dict()
    for param in self.bounds.keys():
      x = trg[param] + random.uniform(0,1)*(rnd1[param] - rnd2[param])
      y[param] = self.clip(param, x)
    return y
  
  def Binomial_crossover(self, x, y):
    #initialization of the output vector as x
    z = x.copy()

    #selecting random param (between 0 and len of keys)
    param = random.choice(self.bounds.keys())

    for p in self.bounds.keys():
      if random.uniform(0,1) < self.cr or p!=param:
        z[p] = y[p]
  
    return z
  
  def clip(self, param, x):
    return max(self.bounds[param][0], min(self.bounds[param][-1], x))

if __name__ == '__main__':
  from sklearn.datasets import load_digits
  from sklearn.svm import SVC
  from sklearn.model_selection import cross_val_score

  data = load_digits()
  n_samples = len(data.images)
  X = data.images.reshape((n_samples, -1))
  Y = data['target']

  def fitness_function(x):
    clf = SVC(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
    scores = cross_val_score(clf, X, Y, cv=5)

    return scores.mean()
  
  bounds = {"C": [0.001, 10.0], "gamma": [0.0001, 0.1]}
  n_pop = 10
  cycles = 10
  #crossover rate
  cr = 0.9

  DE(bounds, cycles, n_pop, cr, fitness_function)