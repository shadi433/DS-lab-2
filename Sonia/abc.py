# -*- coding: utf-8 -*-
"""abc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eUd9GiyiT3n8BCksrypBchpfrCWOyJ-b
"""

import pandas as pd
import numpy as np
import random
from sklearn.datasets import load_digits
from sklearn.svm import SVC
from sklearn.model_selection import cross_val_score

class ABC():
  def __init__(self, bounds, n_pop, cycles, model):
    
    self.bounds = bounds
    self.n_pop = n_pop
    self.cycles = cycles
    self.model = model()
  
    #defining the limit of the trial vector = (Np * D)
    self.limit = self.n_pop * len(self.bounds)

    
    #population generation
    self.XCmin, self.XGmin = self.bounds[0][0], self.bounds[1][0]
    self.XCmax, self.XGmax  = self.bounds[0][1], self.bounds[1][1]

    self.params = ["C","gamma"]
    #keep track of best solution:
    self.best = 0

    self.model = SVC

    def __cal__(self):
      emp_pop_list = self.init_pop()
      #creation of the population dataframe
      emp_pop = self.get_df(emp_pop_list)
      best_sol_index = emp_pop["Fit"].idxmax()
      best_para, best_fit = (emp_pop["C"].loc[best_sol_index],
                         emp_pop["gamma"].loc[best_sol_index]), emp_pop["Fit"].loc[best_sol_index]

      print(">%d, new best C and gamma:%s, best_fit %f" % (best,  best_para, best_fit))
      #setting all the population as employed bees
      #emp_pop["scout"] = 0
      emp_pop["prob"] = 0
      print("init done, cycle entering")
      for _ in range(self.cycles):
        vij = self.produce_new_sol(emp_pop)
        fit = self.fitness_function(vij)
        if fit > f:
          emp_pop.loc[i, ['C']], emp_pop.loc[i, ['gamma']] = vij[0], vij[1]
          emp_pop.loc[i, ['trial']] = 0
        else:
          emp_pop.loc[i, ['trial']] = trial + 1
        best_para, best_fit, best_sol_index = self.keep_track_best_sol(emp_pop, best_fit, best_sol_index)
        #Probability values for the solutions Xij
        emp_pop["prob"] = [f/sum(emp_pop['Fit']) for f in emp_pop['Fit']]
        #we suppose that the onlooker bees will be in the same position
        #as the employed bees
        vij = self.produce_new_sol(emp_pop)
        #evaluation of the new generated solution and update of the trial vector
        fit = self.fitness_function(vij)
        if fit > f:
          emp_pop.loc[i, ['C']], emp_pop.loc[i, ['gamma']] = vij[0], vij[1]
          emp_pop.loc[i, ['trial']] = 0
        else:
          emp_pop.loc[i, ['trial']] = trial + 1
        best_para, best_fit, best_sol_index = self.keep_track_best_sol(emp_pop, best_fit, best_sol_index)
        #generate new solution for the scout bees if exists:
        scout_indexes = emp_pop[emp_pop['trial']>=self.limit].index.values
        if len(scout_indexes) == 0:
          continue
         emp_pop = self.produce_new_sol_scout(emp_pop)
        best_para, best_fit, best_sol_index = self.keep_track_best_sol(emp_pop, best_fit, best_sol_index)
        return best_para
    def init_pop(self):
      emp_pop_list = []
      for _ in range(self.n_pop):
        xc = self.XCmin + random.uniform(0,1)*(self.XCmax - self.XCmin)
        xg = self.XGmin + random.uniform(0,1)*(self.XGmax - self.XGmin)
        emp_pop_list.append((xc, xg))
      return emp_pop_list
    
    def get_df(self, emp_pop_list):
      emp_emp = pd.DataFrame()
      
      #creation of the dataframe with the employed bees
      emp_pop[["C", "gamma"]] = list(emp_pop_list)

      #initialization of the trial vector
      emp_pop['trial'] = 0
      
      #calculating the Fit of the initialised population (employed bees)
      emp_pop["Fit"] = [self.fitness_function(params) for params in emp_pop[["C", "gamma"]].values]
      return emp_pop

    def produce_new_sol(self, emp_pop):
      for i, (c, gamma, trial, f, p) in emp_pop.iterrows():
      vij = [c,gamma]
      #selection of random candidate
      indexes = list(emp_pop.index)
      indexes.remove(i)
      k = random.choice(indexes)
      param = list(set(random.choices(self.params, k = 2)))
      for p in param:
        if p == "C":
          vj = max(self.bounds[0][0],min(self.bounds[0][1],emp_pop[p].loc[i] + random.uniform(0,1)*(emp_pop[p].loc[i] - emp_pop[p].loc[k])))
        else:
          vj = max(self.bounds[1][0], min(self.bounds[1][1], emp_pop[p].loc[i] + random.uniform(0,1)*(emp_pop[p].loc[i] - emp_pop[p].loc[k])))
        vij[self.params.index(p)] = v
      return vij
    
    def fitness_function(self, vij):
        clf = self.model(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
        scores = cross_val_score(clf, X, Y, cv=5)

        return scores.mean()
    def keep_track_best_sol(emp_pop, best_fit, best_sol_index):
      #keeping tracking the best solution:
      if emp_pop["Fit"].max()>best_fit:
        self.best += 1
        best_sol_index = emp_pop["Fit"].idxmax()
        best_para, best_fit = (emp_pop["C"].loc[best_sol_index],
                              emp_pop["gamma"].loc[best_sol_index]), emp_pop["Fit"].loc[best_sol_index]
        print(">%d, new best C and gamma:%s, best_fit %f" % (best,  best_para, best_fit))
      return best_para, best_fit, best_sol_index
    def produce_new_sol_scout(self, emp_pop):
      XCmin = emp_pop['C'].min()
      XGmin = emp_pop['gamma'].min()
      
      XCmax = emp_pop['C'].max()
      XGmax = emp_pop['gamma'].max()

      for index in scout_indexes:
        emp_pop.loc[index, ["C"]] = max(XCmin,min(XCmax,XCmin + random.uniform(0,1)*(XCmax - XCmin)))
        c = emp_pop.loc[index, ["C"]]
        emp_pop.loc[index, ["gamma"]] = max(XGmin, min(XGmax,XGmin + random.uniform(0,1)*(XGmax - XGmin)))
        gamma = emp_pop.loc[index, ["gamma"]]

        emp_pop.loc[index, ["Fit"]] = self.fitness_function([c, gamma])
        emp_pop.loc[index, ["trial"]], emp_pop.loc[index, ["prob"]] = 0,0
      return emp_pop