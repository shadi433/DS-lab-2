# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SZNDuUWmT21xALfqQIiiaQ4_nO2Kar4A
"""

import random

# Calculate the fitness of a bat
def fitness(bat, fitness_function):
	return fitness_function(bat)

# Update the best positions and global best position
def update_positions(population, fitnesses, best_positions, global_best_position):
	for i in range(len(population)):
		if fitnesses[i] > fitness(best_positions[i], fitness_function):
			best_positions[i] = population[i][:]
		if fitnesses[i] > fitness(global_best_position, fitness_function):
			global_best_position = population[i][:]
	return best_positions, global_best_position

# Update the velocity of a bat
def update_velocity(position, best_position, global_best_position, velocity, alpha):
    if len(position) == len(best_position) == len(global_best_position):
        new_velocity = []
        for i in range(len(position)):
            new_velocity.append(velocity[i] + alpha * random.uniform(0, 1) * (best_position[i] - position[i]) + alpha * random.uniform(0, 1) * (global_best_position[i] - position[i]))
        return new_velocity
    else:
        raise ValueError("Lists have different lengths")

# Update the position of a bat
def update_position(bat, velocity, intervals):
    new_position = [b + v for b, v in zip(bat, velocity)]
    for i in range(len(bat)):
        if new_position[i] < intervals[i][0]:
            new_position[i] = intervals[i][0]
        elif new_position[i] > intervals[i][1]:
            new_position[i] = intervals[i][1]
    return new_position

# Generate a new solution for a bat by adding some random noise to its position
def generate_solution(position, intervals):
	return [random.uniform(intervals[i][0], intervals[i][1]) for i in range(len(position))]

# Update the velocity and position of each bat
def update_velocity_and_position(population, velocities, best_positions, global_best_position, alpha, gamma):
	for i in range(len(population)):
		velocities[i] = update_velocity(population[i], best_positions[i], global_best_position, velocities[i], alpha)
		
		# Generate a new solution with probability gamma
		if random.uniform(0, 1) < gamma:
			population[i] = generate_solution(population[i], intervals)
		else:
			population[i] = update_position(population[i], velocities[i], intervals)
	return population, velocities

# Run the bat algorithm to find the optimal solution
def bat_algorithm(fitness_function, pop_size, intervals, max_iter, alpha, gamma):
	# Initialize the population with random bats within the specified intervals
	population = [[random.uniform(intervals[i][0], intervals[i][1]) for i in range(len(intervals))] for _ in range(pop_size)]
	
	# Initialize the velocities with random values
	velocities = [[random.uniform(-1, 1) for i in range(len(intervals))] for _ in range(pop_size)]
	
	# Initialize the best positions with the current positions
	best_positions = population[:]
	
	# Initialize the global best position with the best position of the first bat
	global_best_position = best_positions[0]
	
	# Iterate over the maximum number of iterations
	for _ in range(max_iter):
		# Calculate the fitness of each bat
		fitnesses = [fitness(bat, fitness_function) for bat in population]
		
		# Update the best positions and global best position
		best_positions, global_best_position = update_positions(population, fitnesses, best_positions, global_best_position)
		
		# Update the velocity and position of each bat
		population, velocities = update_velocity_and_position(population, velocities, best_positions, global_best_position, alpha, gamma)
	
	# Return the global best position and the population and fitness of each bat
	return global_best_position, population, fitnesses