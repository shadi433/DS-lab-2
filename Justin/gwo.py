# -*- coding: utf-8 -*-
"""gwo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j-nglT29KzVwYdR_zEcwmljl7uIcAnEq
"""

from __future__ import division
from sklearn import svm
from sklearn.datasets import load_digits
from sklearn.model_selection import cross_val_score

import random
import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation

import math

data = load_digits()

n_samples = len(data.images)
X = data.images.reshape((n_samples, -1))
Y = data['target']

# modle implementation
def fitness_function(x):  
	# x[0] = C and x[1] = gamma
	clf = svm.SVC(kernel='rbf', C=x[0], gamma=x[1], random_state=42)
	scores = cross_val_score(clf, X, Y, cv=5)
	
	return scores.mean()

def boundary_check(x, lb, ub, dim):
    """
    Check the boundary
    :param x: a candidate solution
    :param lb: lower bound
    :param ub: upper bound
    :param dim: dimension
    :return:
    """
    for i in range(dim):
        if x[i] < lb[i]:
            x[i] = lb[i]
        elif x[i] > ub[i]:
            x[i] = ub[i]
    return x

def gwo(pop, lb, ub, iter):
    """
    The main function of GWO
    :param pop: the number of wolves
    :param lb: the lower bound (list)
    :param ub: the upper bound (list)
    :param iter: the iteration number
    :return:
    """
    # Step 1. Initialization
    dim = len(ub)  # dimension
    pos = []
    score = []
    iter_best = []  # the best ever value of each iteration
    for _ in range(pop):
        temp_pos = [random.uniform(lb[i], ub[i]) for i in range(dim)]
        temp_score = fitness_function(temp_pos)
        pos.append(temp_pos)
        score.append(temp_score)
    sorted_score = sorted(score)
    alpha_score = sorted_score[0]
    alpha_pos = pos[score.index(alpha_score)].copy()
    beta_score = sorted_score[1]
    beta_pos = pos[score.index(beta_score)].copy()
    delta_score = sorted_score[2]
    delta_pos = pos[score.index(delta_score)].copy()
    iter_best.append(alpha_score)

    # Step 2. The main loop
    for t in range(iter):
        a = 2 - 2 * (t + 1) / iter
        for i in range(pop):
            for j in range(dim):
                # Calculate the distance between alpha
                r1 = random.random()
                r2 = random.random()
                A1 = 2 * a * r1 - a
                C1 = 2 * r2
                D_alpha = abs(C1 * alpha_pos[j] - pos[i][j])
                X1 = alpha_pos[j] - A1 * D_alpha

                # Calculate the distance between beta
                r1 = random.random()
                r2 = random.random()
                A2 = 2 * a * r1 - a
                C2 = 2 * r2
                D_alpha = abs(C2 * beta_pos[j] - pos[i][j])
                X2 = beta_pos[j] - A2 * D_alpha

                # Calculate the distance between delta
                r1 = random.random()
                r2 = random.random()
                A3 = 2 * a * r1 - a
                C3 = 2 * r2
                D_alpha = abs(C3 * delta_pos[j] - pos[i][j])
                X3 = delta_pos[j] - A3 * D_alpha

                pos[i][j] = (X1 + X2 + X3) / 3

            # Check the boundary
            pos[i] = boundary_check(pos[i], lb, ub, dim)

            # Update the score
            score[i] = fitness_function(pos[i])
            if score[i] < alpha_score:
                alpha_score = score[i]
                alpha_pos = pos[i].copy()
            elif score[i] < beta_score:
                beta_score = score[i]
                beta_pos = pos[i].copy()
            elif score[i] < delta_score:
                delta_score = score[i]
                delta_pos = pos[i].copy()

        iter_best.append(alpha_score)

    # Step 3. Sort the results
    x = [i for i in range(iter + 1)]
    plt.figure()
    plt.plot(x, iter_best, linewidth=2, color='blue')
    plt.ticklabel_format(scilimits=(0, 0))
    plt.xlabel('Iteration number')
    plt.ylabel('So-far best value')
    plt.show()

    return {'best solution': alpha_pos, 'best score': alpha_score}

pop = 10
lb = [1.0, 10.0]
ub = [0.0001, 0.1]

iter = 10
print(gwo(pop, lb, ub, iter))