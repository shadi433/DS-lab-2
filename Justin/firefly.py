# -*- coding: utf-8 -*-
"""firefly_algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dd4HMmJ2gshtoLZBzCuNzu7zkpzTpt9m
"""

import random
import math

# Calculate the fitness of a firefly
def fitness(firefly, fitness_function):
	return fitness_function(firefly)

# Calculate the attractiveness of a firefly based on its brightness and distance from another firefly
def attractiveness(brightness, distance, alpha):
	return brightness * math.exp(-alpha * distance**2)

# Update the brightness of a firefly based on its attractiveness to another firefly
def update_brightness(brightness, attractiveness, beta):
	# Limit the attractiveness to a certain range to prevent the OverflowError error
	attractiveness = min(attractiveness, 50)
	attractiveness = max(attractiveness, -50)
	
	return brightness * math.exp(beta * attractiveness)


# Update the position of a firefly based on its attraction to another firefly
def update_position(position, other_position, gamma):
	new_position = [p + gamma * (op - p) for p, op in zip(position, other_position)]
	return new_position

# Run the firefly algorithm to find the optimal solution
def firefly_algorithm(fitness_function, pop_size, dimensions, max_iter, alpha, beta, gamma):
	# Initialize the population with random fireflies within the specified dimensions
	population = [[random.uniform(dimensions[i][0], dimensions[i][1]) for i in range(len(dimensions))] for _ in range(pop_size)]
	
	# Initialize the brightness of each firefly with a random value
	brightness = [random.uniform(0, 1) for _ in range(pop_size)]
	
	# Iterate over the maximum number of iterations
	for _ in range(max_iter):
		# Calculate the fitness of each firefly
		fitnesses = [fitness(firefly, fitness_function) for firefly in population]
		
		# Update the brightness and position of each firefly
		for i in range(pop_size):
			for j in range(pop_size):
				# Calculate the distance between the two fireflies
				distance = math.sqrt(sum([(a - b)**2 for a, b in zip(population[i], population[j])]))
				
				# Calculate the attractiveness of the two fireflies
				attractiveness_i = attractiveness(brightness[i], distance, alpha)
				attractiveness_j = attractiveness(brightness[j], distance, alpha)
				
				# Update the brightness of the fireflies based on their attractiveness to each other
				if attractiveness_i > attractiveness_j:
					brightness[i] = update_brightness(brightness[i], attractiveness_i, beta)
					population[i] = update_position(population[i], population[j], gamma)
	
	# Find the index of the best firefly
	best_index = fitnesses.index(max(fitnesses))
	
	# Return the best firefly, the population, and the fitness of each firefly
	return population[best_index], population, fitnesses